#### Solution

​	假如我们二分答案 $z$，问题变为，有 $z$ 种石子是有用的，其他石子是没用的，求 Bob 是否有方法让 Alice 把每种石子都拿一个。注意当 Alice 拿到某一种石子之后，相同的其他石子也没用了。

​	一个显然的贪心是如果有没用的石子，那么双方的策略都是优先拿没用的石子。

​	一个正确性不显然的贪心是无论是哪一方，如果没有没用的石子，都会先拿没用的，按照这个实现可以通过 Sub1,2，更精细的实现可以通过 Sub1,2,3,4,5。正确性在后续可以证明。

​	考虑 Sub7 的特殊情况，如果存在一种有用的石子个数不到 $k+1$ 个，则 Alice 可以一直不拿这一堆。如果所有有用的石子都用至少 $k+1$ 个，轮到 Bob 操作时总数 $\bmod (k+1)=k$，所以一定有一个拿法使得操作结束后每堆有用的石子至少有 $k+1$ 个。所以这个条件是充要的，即所有 $a_i$ 都 $\geq k+1$。

​	更一般的情况，我们将有用的石子数量从小到大排序，依次为 $b_0\sim b_z$，另 $w$ 为石子总数之和 $\bmod(k+1)$，特别的，当 $w=0$ 时认为 $w=k+1$。我们声称这里的充要条件是对于所有 $i$，$\sum\limits_{j=0}^i b_j-w+(k+1)i\geq 0$。证明可以用归纳，如果不满足这个条件，则 Alice 可以一直不拿这个集合内的石子，如果满足这个条件 Bob 可以一直用上述的贪心策略，其不会改变 $b$ 的相对顺序，容易归纳。

​	直接实现加上一些特判可以通过 Sub1,2,3,4,5,6,7。

​	再观察这个式子，可以发现其在最后一个 $b_j\leq k+1$ 的位置取到最小值，所以我们可以把问题转为，所有 $\leq k+1$ 的数的和不超过 $w+(k+1)\times($不超过 $k+1$ 的数的个数$)$。也可以进一步用 $k+1-a_i$ 来简化。用线段树二分可以做到 $O((n+q)\log n)$。

​	